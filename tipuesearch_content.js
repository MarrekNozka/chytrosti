var tipuesearch = {"pages":[{"title":"Chyba 🐛","text":"Našli jste chybu? Nebo překlep? Budu velmi rád, když mě na to upozorníte. Všechny zdrojové texty tohoto webu jsou v repositáři na GitHubu . Nejjednodušší způsob jak nahlásit chybu je založit Issue . Pokud se vám chce, můžete… forknout repositáři opravit chybu udělat pull request Díky :-)","tags":"pages","url":"pages/chyba.html","loc":"pages/chyba.html"},{"title":"O mně","text":"Nacházíte se na webových stránkách jednoho šíleného učitele z VOŠ a SPŠE Olomouc . Tyto stránky jsou určeny pro podporu mojí výuky. Každé téma, které aktuálně vyučuji, tady má svou stránku. Některé stránky podávají souhrnné informace, některé jsou jen sbírkou odkazů na jiná místa na Internetu. Pokud vám tu něco chybí, napište mi. Pokud najdete chybu , napište mi. Motto Nikdo nevěděl, odkud přišli, ale najednou byli v Lese: Klokanice a Klokánek. Když se Pú zeptal Kryštůfka Robina: „Jak se sem dostali?\", Kryštůfek Robin řekl: „Obvyklým způsobem, jestli víš, jak to myslím, Pú,\" a Pú, který to nevěděl, řekl: „Aha!\" Pak dvakrát kývl hlavou a řekl: „Obvyklým způsobem. Ach tak!\" Marek Nožka","tags":"pages","url":"pages/o-mne.html","loc":"pages/o-mne.html"},{"title":"Vývoj STM8 s OpenSource nástroji","text":"Vývojové nástroje jsou asi největší slabinou celého ekosystému STM8 . Výrobce dodává vývojové prostředí STVD ( návod zde ), které je sice dostačující, ale staré a již nevyvíjené. Navíc se občas stane, že na nějakém PC je problém to rozjet. Kompilátor Cosmic sice funguje, ale ta neustálá kontrola licence, je fakt opruz; … a jeho chybová hlášení mi taky nepřišly úplně srozumitelná. A to jsem ještě nezmínil to hlavní: Na Linuxu to nejede! Takže, co s tím? Použijeme OpenSource nástroje! Co je potřeba? Vývojové prostředí Kompilátor Programátor/Flasher – software, kterým program do čipu nahraju Debuger Když jsem to celé tvořil hodně mi pomohla tato stránka, tak se tam můžete mrknout: https://github.com/hbendalibraham/stm8_started . Předpřipravená instalace Připravil jsem pro vás výukovou image systému Devuan Linux , kde je vše již nastaveno a nainstalováno. Nemusíte tedy vše ručně instalovat, stačí nainstalovat VirtualBox – včetně Extension Pack a stáhnout si image: Devuan-X- MIT .ova . I tak si ale přečtěte následující text ať víte, jak to máte použít. https://mamut.spseol.cz/nozka/public/site+VirtuaBox/000-obrazy- OVA /Devuan-X- MIT .ova Rychlá instalace Dále v textu jsou popsány detaily. Zde je na jednom místě sepsána rychlá instalace nástrojů, které budete potřebovat. Windows Nejprve nainstalujte Chocolatye . Tedy: Pomocí Win+X a spustíte PowerShell jako Administrátor a zadáte příkaz: Set - ExecutionPolicy Bypass - Scope Process - Force ; [ System . Net . ServicePointManager ]:: SecurityProtocol = [ System . Net . ServicePointManager ]:: SecurityProtocol - bor 3072 ; iex (( New - Object System . Net . WebClient ) . DownloadString ( 'https://community.chocolatey.org/install.ps1' )) Potom doinstalujte další potřebné nástroje: choco install vscodium git make mingw openocd Pokud ještě nemáte Python, můžete i Python: choco install python Instalace SDCC se musí naklikat. Instalátor stáhnete zde: https://sourceforge.net/projects/sdcc/files/sdcc-win64/ Linux sudo apt install sdcc sdcc-libraries git make openocd Startovací toolchain Připravil jsem startovací strom zdrojových kódů a Makefile . https://github.com/spseol/ STM8 -start-toolchain Tento toolchain se dá použít jak v Linuxu tak ve Windows. Stačí nainstalovat Make , Bash a/také Git . V Linuxu zavoláte něco jako: apt install make git Ve Windows je nejsnadnější instalovat pomocí Chocolatye : choco install make choco install git (Bash je součásti balíčku Git.) Adresářová struktura jednotlivých projektů vypadá takto: MIT ├── Projekt-1 │ ├── inc │ ├── lib │ └── src ├── Projekt-2 │ ├── inc │ ├── lib │ └── src ├── SPL-STM8S103 │ ├── inc │ └── src ├── SPL-STM8S105 │ ├── inc │ └── src └── SPL-STM8S208 ├── inc └── src Udělejte si adresář, kde budou všechny vaše projekty. V tom stejném adresáři budou i adresáře nazvané SPL . V SPL adresářích je Standard peripheral library od firmy ST . Tato knihovna má dost divnou licenci a proto vám ji nemůžu jen tak dát. Měli byste si ji najít a stáhnout . Pak je třeba ještě aplikovat patch , který knihovnu předělá tak, aby se dala použít s naším SDCC kompilátorem. No prostě: ve svém prvním projektu zadáte příkaz: make spl Vývojové prostředí Jako editor a vývojové prostředí doporučuji VScodium/VScode . Instalace je popsána zde Kompilace Popíšu tu celkem tři různá, mezi sebou se prolínající řešení. Špatná zpráva je, že ani jedno z nich není 100%. Dobrá zpráva je, že při troše snahy se těm 100% můžeme hodně přiblížit. Mezi jednotlivými řešeními se můžete snadno přepnout: make switch-sdcc respektive make switch-sdccrm respektive make switch-sdcc-gas K dispozici jsou tedy celkem tři Makefile v adresáři .make . Přepnutí jen znamená, že se udělá symlink do root-adresáře projektu. Na divných systémech, které symlink neumí (například Windows) se natvrdo kopíruje, takže tato operace může být ztrátová. Řešení 1: sdcc SDCC - Small Device C Compiler je kompilátor pro různé, více či méně známé 8-bitové architektury. Z hlediska STM8 má jednu zásadní nevýhodu: nedokáže odstranit nepoužívaný kód . Co to znamená? No… pokud si všechno píšete sami, tak to prakticky neznamená nic. Pokud ovšem použijete nějakou knihovnu (jako například SPL ), tak už vám to začne hodně vadit, protože výsledný strojový kód obsahuje spoustu funkcí, které jste kompilovali jen proto, že byli součástí knihovny a ne proto, že jste je chtěli použít. Tyto funkce nejsou nikde volány a proto by je měl linker odstranit. No a to je přesně to, co se nestane :-( . Ve výsledku program, který by mohl mít cca 2-3 kB má 30 kB. To se dá částečně vyřešit tím, že budete kompilovat jen ty části SPL , které právě v tomto projektu potřebujete. Velikost výsledného binárního souboru se tak rapidně zmenší, ale pokud budete pracovat s čipem, který má jen 8 kB paměti programu, obávám se, že to nemusí stačit…. V Makefile někde kolem řádku 77 najdete toto: SPL_SOURCE = stm8s_gpio.c stm8s_clk.c stm8s_tim4.c stm8s_itc.c #SPL_SOURCE += stm8s_uart1.c SPL_SOURCE += stm8s_adc2.c #SPL_SOURCE += stm8s_flash.c #SPL_SOURCE += stm8s_tim1.c #SPL_SOURCE += stm8s_tim2.c #SPL_SOURCE += stm8s_tim3.c … měli byste zakomentovat to, co nepotřebujete a odkomentovat jen to, co potřebujete. Instalace v Linuxu je poměrně snadná, protože SDCC je součásti většiny Linuxových distribucí; takže zavoláte něco jako: apt install sdcc sdcc-libraries Ve Windows si stáhnete instalátor a pokračujte, ve Windows oblíbeným klikáním. Řešení 2: sdccrm sdccrm je nástroj pro optimalizaci mrtvého kódu pro port stm8 SDCC , který odstraňuje nepoužívané funkce. https://github.com/XaviDCR92/sdccrm Je to řešení tak nějak na půl cesty: Funguje, kód je opravdu menší, ale tato možnost vylučuje použití debugeru . To někdy, někomu vadit může, jindy jinému to vadit nemusí. Dále je nutné ručně zadat funkce, které nechcete \"optimalizovat\" – tedy vyhodit. Proto je třeba sledovat chybová hlášení a název chybějící funkce zadat do souboru .make/exclude_reference uvnitř projektového adresáře. sdccrm si musíte buildnout ze zdrojových kódů. Pomocí Chocolatye nainstalujete gcc a v adresáři se zdrojovými soubory zavoláte make . sdccrm je celkem malý program bez závislostí, takže jde jednoduše kompilovat v Linuxu i ve Windows – nicméně pro jistotu je Windows binárka součástí startovacího toolsetu a je v souboru .make/sdccrm.exe . choco install mingw a pak cd sdccrm make Řešení 3: sdcc-gas https://github.com/XaviDCR92/sdcc-gas Toto je asi nejlepší řešení. Vzniklo přidáním podpory GNU Assembleru tedy -gas do SDCC 3.9.0; gas je výhodou i nevýhodou tohoto řešení. Na jednu stranu to znamená, že můžeme používat klasické nástroje z GNU binutils , na druhou stranu to znamená, že nelze použít ty části sdcc-libraries , které jsou napsané v STM8 assembleru a je nutné použít méně optimální kód napsaný v C. …no a zřídka se stane, že nějaká vnitřní funkcionalita (například násobení 64-bitových integerů) je napsaná jen v STM8 assembleru a vám nezbude, než to nějak obejít nebo danou funkci přepsat do GNU assembleru. Pokud vás to zajímá více můžete si počíst zde a zde Toto je důvod proč v Makefile sdcc-gas jsou tyto řádky: SDCC_LIB_SRC_DIR = /usr/local/stow/sdcc-gas/share/sdcc/lib/src/ SDCC_LIB_SOURCE = _mullong.c _divulong.c _mulint.c _modsint.c #SDCC_LIB_SOURCE = $(notdir $(wildcard /usr/local/stow/sdcc-gas/share/sdcc/lib/src/_*.c)) SDCC_LIB_OBJECTS := $( addprefix $( OUTPUT_DIR ) /, $( SDCC_LIB_SOURCE:.c = .o )) Případné problémy chybějících funkcí lze tedy vyřešit doplněním jména souboru do proměnné SDCC_LIB_SOURCE . Aby vše fungovalo musíte si stáhnout výše zmíněné zdrojové kódy a buildnout je. Já to dělám takto (používám stow ): sudo apt install stow sudo apt build-dep sdcc cd sdcc-gas ./configure --prefix = /usr/local/stow/sdcc-gas make sudo make install cd /usr/local/stow sudo stow sdcc-gas Podobný postup použijete pro STM8 port GNU binutils, který je potřeba pro linkování a debug .: tar xzf stm8-binutils-gdb-sources-2021-07-18.tar.gz cd stm8-binutils-gdb-sources export PREFIX = /usr/local/stow/stm8-binutils-gdb ./patch_binutils.sh cd binutils-2.30 make sudo make install cd /usr/local/stow sudo stow stm8-binutils-gdb Tato výše popsaná kompilace ze zdrojových kódů je teoreticky možná i na Windows, pomocí projektu Cygwin . Prakticky jsem to nikdy nezkoušel. Osobně bych šel (tedy pokud by mě někdo donutil používat Widows) spíše cestou Windows Subsystem for Linux . Instalace WSL 2 je velice jednoduchá . Bohužel do WSL se nativně nedá připojit USB – ale dá se to řešit . Flashing OpenOCD Open On-Chip Debugger je nástroj pro debug a krokování programu přímo na čipu. openocd umí i nahrát program do paměti zařízení. Instalaci zajistí na Linuxu jednoduchý příkaz: sudo apt install openocd na Windows je to díky Chocolatye podobně jednoduché. choco install openodc Zdá se, že Chocolatye už nabízí verzi 0.11. Dříve to bylo jen 0.10. Tyto verze používají trochu jiné názvy souborů, proto i příkaz vypadá jinak. Verze 0.10: openocd -f interface/stlink.cfg -f target/stm8s.cfg Verze 0.11: openocd -f interface/stlink-dap.cfg -f target/stm8s.cfg Toto se řeší v Makefile pomocí proměnné OPENOCD , takže si ji případně upravte. Aby openodc umělo i pouhé flashování je třeba přidat přidat skript, který to umí. Ten je buď součástí startovacího toolsetu nebo ho můžete přidat na konec konfiguračního souboru stm8s.cfg : proc program_device { filename flashstart } { halt wait_halt load_image $ filename $ flashstart sleep 10 reset halt resume sleep 10 shutdown } ; V Linuxu by celá cesta mohla vypadat takto: /usr/share/openocd/scripts/target/stm8s.cfg . Pokud jste do Windows instalovali pomocí Chocolatye, bude to nejspíš tato cesta: C:\\ProgramData\\chocolatey\\lib\\openocd\\tools\\OpenOCD-20190828-0.10.0\\share\\openocd\\scripts\\target\\stm8s.cfg . stm8flash Druhá možnost je program stm8flash . Ve většině linuxových distribucí je třeba ho ručně buildnout. https://github.com/vdudouyt/stm8flash Debug stm8-gdb STM8 Debugger for vsCode/Codium","tags":"MITka","url":"vyvoj-stm8-s-opensource-nastroji.html","loc":"vyvoj-stm8-s-opensource-nastroji.html"},{"title":"Sítě","text":"Videa","tags":"SÍTě","url":"site.html","loc":"site.html"},{"title":"MIT","text":"Pro výuku mikroprocesorové techniky používáme vývojovou desku Nucleo- 8S208RB s mikroprocesorem STM8S208RB . Dokumentace Celá řada STM8S používá stejnou sadu periferií. Jejich popis najdete v reference manuálu zde . Různé čipy pak obsahují různou sadu těchto periferií. Co přesně se nachází na kterém čipu (plus další specifické věci) lze najít v datasheetu: STM8S208 zde STM8S103 zde STM8S105 zde Přehled jednotlivých čipů jednotlivých řad rodiny STM8S pak najdete zde: Application Specific Line STM8S Value line STM8S103 /105 STM8S207 /208 Návody Michal Dudka píše skvělý web o programování mikrokontrokérů: http://elektromys.eu . V sekci STM8 najdete spoustu pro nás zajímavých věcí: Vstupy a výstupy 1 – základy Vstupy a výstupy 2 – tlačítko Vstupy a výstupy 3 – logické úrovně Vstupy a výstupy 4 – PullUp rezistory Vstupy a výstupy 5 – Open-Drain Ovládání displeje s MAX7219 Clock Alfanumerické LCD Knihovna milis – \"Multitasking\" Stavový automat Pro potřeby svojí výuky jsem napsal následující: Generování zvuku – základy Základní použití časovače Použití časovače jako generátoru PWM Ultrazvukový měřič vzdálenosti pomocí timeru TIM2 Ze dílny Michala Dudky najdete pochází tyto pro nás zajímavé články: IR senzor I2C – Relativně jednoduše Další velice cenné informace nejdete v sekcích: Elektro Různé krátké poznámky Projekty Toto by se vám mohlo hodit: seznam na TME seznam na LaskArduno Podmínky a zadání najdete na školním drajvu . Nástroje Vývojové nástroje jsou IMHO největší slabina platformy STM8 , ale při troše snahy se to dá :) . Co se ale ST povedlo, to je nástrtoj STM8CubeMX . Doporučuji si ho nainstalovat. Není nijak klíčový, ale hodí se. OpenSource nástroje nejen pro Linux Celou problematiku jsem zpracoval v samostatném návodu: Vývoj STM8 s OpenSource nástroji . Ve zkratce to vypadá takto: Kompilátor SDCC Jako vývojové prostředí doporučuji VSCodium Starší anglický návod s několika mouchama: https://github.com/hbendalibraham/stm8_started Nástroje pro Widle Vše velmi hezky zpracoval Michal Dudka na Elektromyši . Jako vývojové prostředí leze použít STVD s komipilátorem Cosmic . Oba nástroje je možné bezplatně používat, když se zaregistrujete. Bohužel nejsou ani jeden OpenSource . Šablona pro založení projektu moje šablona pro vývoj SDCC a GNU Make https://github.com/spseol/start-stm8 vzorový projekt Michala Dudky ( STVD ) http://www.elektromys.eu/stm8s208_vzor.rar (případně zip) http://www.elektromys.eu/stm8s105_vzor.rar (případně zip) Odkazy http://www.fit.vutbr.cz/~martinek/clang/ http://jaknaprojekty.davidm.cz/ https://www.tutorialspoint.com/cprogramming/ Wikibook Programuje v jazyce C .","tags":"MITka","url":"mit.html","loc":"mit.html"},{"title":"Git","text":"Git najdete na https://git-scm.com/ . Ovládá se z příkazové řádky. Pokud toužíte po nějakém grafickém ovládání stačí si vybrat z dlouhého seznamu ten, co se vám bude zdát nejhezčí. GitHub má svou vlastní grafickou aplikaci . Vynikajícím začátkem s Gitem je volně šiřitelná kniha Pro Git , ve které najdete vše potřebné v češtině. Lze číst i na webu: první vydání – celé v češtině druhé vydání – není přeloženo celé; můžete se tedy zapojit do překladu . Pro efektivní používaní tohoto skvělého nástroje vám stačí přečíst si první tři kapitoly . Nenechte se tedy odradit, stojí to jistě za to. Zde je ještě malý rychlokurs (pokud někdo není spokojen s knihou): Git Instalace gitu Větvení v Gitu Ignorování souborů Spolupráce a Open source Spolupráce a Git Ještě jedna drobnost: pokud se vám nechce pořád dokola zadávat při nahrávání své práce na GitHub uživatelské jméno a heslo použijte ssh klíče . K tomu se dobře hodí například putty . Instalace Doporučuji použít Chocolatey choco install git Počáteční nastavení Než budete Git používat, je třeba nakonfigurovat vaše jméno a e-mail. Je to proto, jméno a e-mail autora je součástí každého snímku – commitu. git config --global user.name \"John Doe\" git config --global user.email john@doe.name Parametr --global říká, že je to nastavení pro celý uživatelský účet. Pokud ho nepoužijete, bude se nastavení týkat jen toho repositáře, ve kterém příkaz spustíte. SSH Pokud chcete (ano chcete) používat nějaké vzdálené úložiště (např. GitHub nebo GitLab ), je SSH jeden se způsobů jak (pohodlně) přenášet data mezi lokálním a vzdáleným repositářem. Nejprve je třeba si vygenerovat key-pair . ssh-keygen nebo ssh-keygen -t ed25519 Během generování budete dotazování na passphrase. Pokud tuto doplňkovou ochranu nechcete použít a stačí vám utajení klíče, který bude ležet na vašem disku, dejte jen dvakrát Enter. Pozorně sledujte kam se klíče uloží. Třeba v Linuxu je to ~/.ssh/id_ed25519 pro tajný/privátní klíč a ~/.ssh/id_ed25519.pub pro veřejný klíč. Celá akce končí tím, že svůj veřejný klíč – tedy obsah souboru s příponou .pub , uložíte do svého profilu na GitHub/GitLab: Settings -> SSH and GPG keys . Další detaily naleznete například v tomto článku na AbcLinuxu . HTTPS Druhým, alternativním způsobem přenosu dat je protokol HTTPS . Zde je třeba při každém přenosu zadávat jméno a heslo. Pokud používáte nějakou klíčenku pro ukládání hesel můžete to Gitu říct takto: git config --global credential.helper klicenka_cmd Pokud klíčenku nepoužíváte nebo chcete, aby vaše přihlašovací údaje uchovával přímo Git v nešifrované podobě , je to tento příkaz: git config --global credential.helper store Git se vás pak na vaše přihlašovací údaje zeptá jen jednou a uloží se je do souboru ~/.git-credentials . Ten může vypadat třeba takto: https://jmeno:personal_token@github.com https://jmeno:heslo_nebo_token@gitlab.com Pokud si má Git přihlašovací údaje pamatovat jen dočasně nastaví se .helper na cache . Je ještě dobré podotknout, že GitHub neumožňuje přihlášení pomocí hesla: je nutné si vygenerovat Personal access token . (Až ho budete generovat, tak v právech odfajfkujte workflow .) Veřejná (webová) úložiště Nejznámější veřejná úložiště pro Git jsou asi tyto: https://github.com https://gitlab.com https://bitbucket.org Kromě ukládaní repositářů zde naleznete i rozměr sociální sítě. Asi se nedá říct, že jeden je lepší a druhý horší. Každý má svá pro a proti. Pokusy a hračičky https://learngitbranching.js.org/ Oh my Git: https://ohmygit.org/","tags":"Programování","url":"git.html","loc":"git.html"},{"title":"VSCode/Codium","text":"V poslední době se mi jako editor nejvíc osvědčil VSCode/Codium. Já osobně sice používáme VIm , ale ve výuce a se studenty používáme VSCode/Codium. Visual Studio Code je brilantní open-source editor z dílny firmy Microsoft s vestavěnou podporou pro systém Git . Editor je multiplatformní, takže je jedno jestli používáte MacOS, Linux nebo (nechápu proč by to někdo nělal…) Windows. Pokud by vám (stejně jako mně) vadilo, že Microsoft do balíčku s VSCode zabalí i telemetrii (dřív se tomu říkalo špehování), tak existuje projekt Codium , který tímto neduhem netrpí. Oba projekty pochází ze stejných zdrojových kódů. Liší se pouze v tom, jak jsou zabaleny. Codium neobsahuje telemetrii a má marketplace nasměrovaný trošku jinam . Z toho vyplývá, že mohou nastat problémy při instalaci některých doplňků, protože na open-vsx.org nejsou všechny doplňky, které najdete na oficiálním maktetplacu a naopak. Pokud se v této situaci ocitnete a opravdu moc toužíte po onom úžasném doplňku, který na open-vsx.org prostě není, stačí ho z oficiálním maktetplacu stáhnout a v Codiu ručně nainstalovat. Instalace V Linuxu závisí instalace hodně na konkrétní distribuci. Například na Ubuntu se to prý dělá takto: sudo apt install snapd sudo snap install codium --classic Nebo můžete použít například vscodium-deb-rpm-repo . … a nebo všechno udělat růčo . Nejjednodušší způsob instalace ve Windows je pomocí Chocolatey . choco install vscodium choco install vscode Python Pokud si doinstalujete doplněk ms-python.python ( zde nebo zde ) získáte vývojové prostředí, ve kterém vám s největší pravděpodobností nebude nic chybět. Flask/Jinaja2 Dalším užitečným doplňkem je Better Jinja ( samuelcolvin.jinjahtml respektive samuelcolvin.jinjahtml ). Zde je dobré ještě říct, že když používáte šablony Jinja pro web, chcete většinou, aby vám fungovalo napovídání jak HTML , tak Jinja. Toho docílíte tak, že v nastavení si přidáte do Include Languages : \"jinja-html\": \"html\" Git Git je v Codiu již integrován v základní podobě. Vše další po čem byste mohli v této oblasti toužit dostanete instalací doplňku Git Extension Pack pinage404.git-extension-pack . Ten v instaluje sadu doplňků: GitLens eamodio.gitlens Git Graph mhutchie.git-graph Git Project Manager felipecaputo.git-project-manager Git Web Links reduckted.vscode-gitweblinks Céčko V souvislosti s jazykem C stojí za zmínku alespoň tyto dva doplňky: C/C++ for Visual Studio Code ms-vscode.cpptools clangd llvm-vs-code-extensions.vscode-clangd respektive llvm-vs-code-extensions.vscode-clangd Já používám ten druhý, ale možná si budete chtít vyzkoušet a nastavit ten první… STM8 Opět stojí za zmínku dva doplňky. Já mám zkušenost s tímto: STM8 Debugger CL .stm8-debug … ale jistě stojí za zmínku i toto: Embedded IDE CL .eide respektive CL .eide","tags":"Programování","url":"vscodecodium.html","loc":"vscodecodium.html"},{"title":"Chocolatey","text":"Chocolatey je správce balíčků pro operační systém windows. Dá se říct, že se snaží o co nejjednodušší instalaci software. Podobný způsob instalace je znám z linuxových distribucí. Já tento způsob instalace doporučuji a zatím se mi jen a jen osvědčil. Nemusíte SW nikde dlouze hledat instalovat atd. Například instalaci VSCodia a Pythonu zajistí tyto dva příkazy: choco install vscodium choco install python Pokud vás zajímá co všechno v repositáři balíčků najdete koukněte se na https://community.chocolatey.org/packages . Instalace chocolatey Celý projekt na jdete na stránce https://chocolatey.org . Pokyny jak to celá nainstalovat potom na https://chocolatey.org/install . Když to hodně zjednoduším: Pomocí Win+X a spustíte PowerShell jako Administrátor a zadáte příkaz: Set - ExecutionPolicy Bypass - Scope Process - Force ; [ System . Net . ServicePointManager ]:: SecurityProtocol = [ System . Net . ServicePointManager ]:: SecurityProtocol - bor 3072 ; iex (( New - Object System . Net . WebClient ) . DownloadString ( 'https://community.chocolatey.org/install.ps1' )) Pokud chcete nějaké klikátko tak ho doinstalujete příkazem: choco install chocolateygui Python Pokud pracujete s Pythonem stačí nainstalovat VSCodium nebo VScode… a Python a taky asi Git choco install vscodium choco install vscode choco install python choco install git STM8 Pokud pracujete v MIT s STM8 nainstalujete VSCodium nebo VScode… a Git a GNU Make a OpenOCD. No a GCC a Python se taky docela hodí. choco install vscodium choco install vscode choco install git choco install make choco install openocd choco install mingw choco install python","tags":"Programování","url":"chocolatey.html","loc":"chocolatey.html"},{"title":"pip","text":"pip je instalátor balíčků pro Python. Kromě toho, že umí nainstalovat balíček, tak umí nainstalovat i všechny jeho závislosti a umí tyto balíčky spravovat. To znamená, že kromě akce install existuje i akce unistall nebo list . Někdy se stane, že při zadání příkazu pip obdržíte pouze hlášení, že příkaz neexistuje. Buď jste při instalaci nezadali, že se má nainstalovat, nebo nejsou příslušné cesty obsaženy v proměnné PATH . V obou dvou případech doporučuji znovu spustit instalátor a zaškrtnou příslušná políčka. V Linuxu potom stačí něco jako: apt install python3-pip python3-venv Notice Ještě jedna poznánka k Linuxu: V Linuxových distribucích bývá Python většinou už nainstalován – a to dokonce dvakrát. Příkazem python spustíte Python2 a příkazem python3 spustíte Python3 . Obdobně to platí pro příkaz pip a pip3 . Také se může stát, že modul pip nainstalován je, ale příkaz pip ne. Pro tyto případy a také pro vysvětlení některých nejasností: místo příkazu pip můžete zadat delší příkaz python -m pip případně… python3 -m pip celý příkaz může tedy vypadat například takto: python3 -m pip install -U --user flask namísto… pip install -U --user flask Ještě než se dáte do instalace zvažte zda instalovat pro celý systém, virtuální prostředí nebo jen pro jednoho uživatele? Dále je dobré si všímat žlutých varovných hlášení a řídit se jejich radou: Warning WARNING : You are using pip version 21.2.4; however, version 21.3.1 is available. You should consider upgrading via the ‘/usr/bin/python3.9 -m pip install –upgrade pip' command. Hodně zásadní je chybové hlášení, které může vypadat například takto: Warning WARNING : The scripts pip, pip3 and pip3.9 are installed in ‘/home/marek/.local/bin' which is not on PATH . Consider adding this directory to PATH or, if you prefer to suppress this warning, use –no-warn-script-location. Spustitelný skript se nainstaloval tam, kde ho váš shell nenajde. Je třeba toto místo přidat do proměnné PATH . Ve Windows to musíte naklikat, v Linuxu je to soubor ~/.profile nebo ~/.zprofile (podle toho, jaký používáte shell). PATH=~.local/bin:$PATH Globální instalace Pokud budete balíček instalovat globálně pro celý systém potřebujete administrátorská práva. Je třeba se ujistit, že si tím nepokazíte něco, co už nainstalované máte. Mohlo by se stát, že máte nainstalovanou nějakou aplikaci, která potřebuje knihovnu verze x.y a vy nyní nainstalujete tu stejnou knihovnu verze y.z . Na Windows toto většinou (někdy tedy ano) řešit nemusíte, na Linuxu typicky ano. (Na druhou stranu v Linuxu můžete spoustu knihoven nainstalovat i bez pip u z repositářů vaší distribuce: apt install pytho3-flask .) Takže spustíte si příkazový řádek a jako superuživatel a zadáte něco jako: pip install flask pip install pyglet pip install jmeno_balicku Uživatelská instalace K uživatelské instalaci nepotřebujete administrátorská práva, protože balíčky se instalují do vašeho domovského adresáře (profilu). Na Linuxu je to typicky adresář ~/.local/lib/python3.X pro balíčky a ~/.local/bin pro spustitelné skripty. pip install --user flask pip install --user pyglet Pokud už je daný balíček nainstalován v systému a vy chcete novější verzi jen do uživatelského profilu, je třeba to vynutit parametrem -U , který říká, že má balíček povýšit/instalovat na nejnovější dostupnou verzi. pip install -U --user flask Virtuální prostředí? Virtuální prostředí umožňuje mít instalaci Pythonu (jakoby) oddělenou od instalace v systému. Pro každý projekt si vytvoříte vlastní virtuální prostředí a do něj instalujete potřebné balíčky v potřebné verzi. Ostatní systém a ostatní balíčky si toho vůbec nevšimnou. Vytvoření Nejprve je třeba virtuální prostředí vytvořit. Např. do adresáře .venv-projekt1 : python3 -m venv .venv-projekt1 Aktivace Před začátkem práce je třeba vždy prostředí aktivovat. V Linuxu: source .venv-projekt1/bin/activate Ve Windows .venv-projekt1 \\ Scripts \\ activate.bat Práce Prostředí je aktivováno a pokud tu pustíte Python bude vidět jen to, co je zahrnuto v tomto virtuálním prostředí. Pokud pustíte pip , bude instalovat do tohoto prostředí. pip install -U pip pip install flask Deaktivace deactivate Aktualizace Balíčků Aktualizace balíčků na nejnovější dostupnou verzi provedete parametrem -U . pip install -U pip pip install -U flask nebo pip install --user -U pip pip install --user -U pyglet","tags":"Programování","url":"pip.html","loc":"pip.html"},{"title":"DBI","text":"Python Programujeme v jazyce Python, proto zde platí prakticky vše, co pro PRG . Instalace knihoven Budeme potřebovat modul Flask . Jeho instalaci zajistí pip . Doporučuji přečíst si celý post věnovaný pipu . Ve Windows to může vypadat třeba takto: pip install flask V Linuxu spíš takto: pip3 install --user flask Git Pro sdílení práce a odevzdávání domácích úkolů používáme systém Git a server GitHub . Stojí také za to, zmínit se o GitHub programu pro vzdělávání . Gitu se věnuji v samostatném postu . Dokumentace Python: https://docs.python.org/ Flask: https://flask.palletsprojects.com/ Quickstart Message Flashing Incoming Request Data Patterns Jinja2: https://jinja.palletsprojects.com/templates/","tags":"Programování","url":"dbi.html","loc":"dbi.html"},{"title":"PRG","text":"Tahák Vytvořil jsem tahák, kde je z Pythonu více-méně vše, co byste měli mít v pohotovostní výbavě. Tyto texty lze číst buď na Githubu nebo nbvieweru . Instalace návod zde . Klíčové je nainstalovat i pip a přidat si Python do proměnné prostředí PATH : Add Python to PATH , add Python to enviroment variables . Editor Základní instalace Pythonu už sama v sobě obsahuje jednoduché vývojové prostředí a jednoduchou interaktivní konzolu IDLE . Toto prostředí je poměrně jednoduché, ale rozhodně se nedá říct, že by se v něm nedalo pracovat. Existuje ale celá řada hezčích a propracovanějších vývojových prostředí . Já doporučuji VSCode/Codium . Git Pro sdílení práce a odevzdávání domácích úkolů používáme systém Git a server GitHub . Stojí také za to, zmínit se o GitHub programu pro vzdělávání . Gitu se věnuji v samostatném postu Git . Dokumentace Naprostou většinu všech vašich dotazů vyřeší Kačer prostým dotazem . Nicméně považuji za dobré zmínit, že Python má svou vlastní – docela dobrou – dokumentaci . Knihovny Knihovny se nejlépe instalují pomocí pip . Tématu se věnuji v samostatném postu Pip .","tags":"Programování","url":"prg.html","loc":"prg.html"},{"title":"PSK","text":"Linux Základy počítačových sítí","tags":"PSKáčko","url":"psk.html","loc":"psk.html"},{"title":"Ultrazvukový měřič vzdálenosti pomocí timeru TIM2","text":"zde se časem objeví zajímavý text :) Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: základní princip – větev princip main.c řešení typu Stavový automat – větev stav_automat main.c","tags":"MITka","url":"ultrazvukovy-meric-vzdalenosti-pomoci-timeru-tim2.html","loc":"ultrazvukovy-meric-vzdalenosti-pomoci-timeru-tim2.html"},{"title":"Použití časovače jako generátoru PWM","text":"TIM2 a TIM3 zde se časem objeví zajímavý text :) Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: RGB LED – RGB_LED main.c","tags":"MITka","url":"pouziti-casovace-jako-generatoru-pwm.html","loc":"pouziti-casovace-jako-generatoru-pwm.html"},{"title":"Generování zvuku — základy","text":"Zvuk je jak známo mechanické vlnění. Pro jeho vyloudění tedy potřebujeme nějaký \"vlnič\" – tedy elektro-akustický měnič. Nejjednodušší je asi použít piezo měnič. Ten má ovšem poněkud omezený frekvenční rozsah. Jeho frekvenční charakteristika může vypadat například takto: (Mimochodem prý existuje nějaký výzkum, podle kterého optimální frekvence pro budík je 100 Hz; nebo to bylo 300 Hz? Prostě poměrně nízký kmitočet. Ale levné bezporuchové piezo-měniče takto nízko prostě nejdou. Tak na nás ty budíky pískají a pípají a my vstáváme potom naštvaní.) Další možností je použít reproduktorek. V tomto případě je třeba posílit výstup tranzistorem. Zapojení tedy může vypadat například takto: Tranzistor je ve spínacím režimu a membrána reproduktoru má pouze dvě polohy. Tedy klidovou polohu (bez proudu) nebo výchylku odpovídající kladnému proudu. Do výchylky odpovídající zápornému proudu se membrána nedostane, protože proud protéká vždy jedním směrem. Dioda D1 vybíjí cívku reproduktoru, při sestupné hraně. Program, který nám vyloudí frekvenci \\(500\\,\\mathrm{Hz}\\) může vypadat například takto. Perioda je \\(2\\,\\mathrm{ms}\\) . Půl periody tedy \\(1\\,\\mathrm{ms}\\) . void main ( void ) { init (); while ( 1 ) { PZ_UP ; delay_ms ( 1 ); PZ_DOWN ; delay_ms ( 1 ); } } Pokud chci jen pípnout a poté nechat chvilku ticho jednoduše nebudu cvičit s membránou do nekonečna, ale pouze několikrát ( \\(20 \\cdot 2\\,\\mathrm{ms}\\) ) a pak nechám chvilku ticho. void main () { init (); uint16_t i ; while ( 1 ) { for ( i = 0 ; i < 20 ; ++ i ) { PZ_UP ; delay_ms ( 1 ); PZ_DOWN ; delay_ms ( 1 ); } delay_ms ( 60 ); } } Tento způsob práce je ale blokující, protože se pořád jen čeká. Mikroprocesor vlastně pořádně nemůže dělat nic jiného. Proto použijeme multitasking 1 a stavový automat . void main ( void ) { uint32_t timeL = 0 ; uint32_t lastTime = 0 ; uint16_t count = 0 ; enum state_of { STATE_PAUSE , STATE_UP , STATE_DOWN } state = STATE_UP ; uint32_t time = 0 ; init (); while ( 1 ) { switch ( state ) { case STATE_PAUSE : PZ_DOWN ; // v pauze dám repráček do klodového stavu if ( milis () - lastTime > 4321 ) { lastTime = milis (); state = STATE_UP ; } break ; case STATE_UP : PZ_UP ; if ( milis () - lastTime >= 4 ) { lastTime = milis (); state = STATE_DOWN ; } break ; case STATE_DOWN : PZ_DOWN ; if ( count >= 10 ) { count = 0 ; lastTime = milis (); state = STATE_PAUSE ; break ; } if ( milis () - lastTime >= 4 ) { lastTime = milis (); count ++ ; state = STATE_UP ; } break ; default : state = STATE_PAUSE ; } if ( milis () - timeL > 500 ) { timeL = milis (); LED_REVERSE ; } } } Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: https://github.com/spseol/ STM8 -zvuk-zaklad knihovna milis ↩","tags":"MITka","url":"generovani-zvuku-zaklady.html","loc":"generovani-zvuku-zaklady.html"},{"title":"Základní použití časovače","text":"Náš STM8S208RB má na těle celkem čtyři časovače: TIM1 , TIM2 , TIM3 a TIM4 . TIM4 TIM4 je nejjednodušší. Čítač je 8-bitový a předdělička umožňuje dělit kmitočet /1, /2, /4, /8, /16, /32, /64 a /128. Auto-reload register říká kam až se bude čítat – tedy nastavuje strop časovače. Nastavení se děje pomocí funkce TIM4_TimeBaseInit(PRESCALER, PERIOD) , kde PRESCALER je makro, pro nastavení děličky a PERIOD je 8-bitové číslo. TIM4_TimeBaseInit ( TIM4_PRESCALER_128 , 125 - 1 ); Takže pokud máme nastaven kmitočet na 16MHz znamená to že čítač čítá do hodnoty 125 (respektive 124 protože čítáme od nuly) s frekvencí 16MHz/128 == 125 kHz . Znamená to tedy, že každou milisekundu dojde k auto-reloadu a je vyvoláno přerušení od časovače TIM4 . Aby vše fungovalo musíme: povolit TIM4 povolit přerušení od TIM4 globálně povolit přerušení napsat tělo obslužné rutiny přerušení. void setup ( void ) { TIM4_Cmd ( ENABLE ); // povolí TIM4 TIM4_ITConfig ( TIM4_IT_UPDATE , ENABLE ); // povolí přerušení od TIM4 enableInterrupts (); // globálně povolí přerušení ...... } Rutina přerušení se standardně nachází v souboru stm8_it.c . Stačí ji najít přepsat. Pokud potřebujete v rutině přerušení pracovat s proměnnou definovanou v main.c (což je myslím téměř vždy) je třeba tuto proměnnou označit direktivou extern nebo rutinu přesunout přímo do souboru main.c . Více o tom se dočtete v postu Kompilace a knihovny . /*--- rutina obsluhy přerušení ---*/ INTERRUPT_HANDLER ( TIM4_UPD_OVF_IRQHandler , 23 ) { TIM4_ClearFlag ( TIM4_FLAG_UPDATE ); // vymažu vlajku signalizující přerušení miliseconds ++ ; // udělám co je třeba.... } Všimněte si prosím, že první, co se v rutině přerušení dělá, je, že se vymaže vlajka , která označuje, že k přerušení došlo. Tento kód je například použito v knihovně milis , která umožňuje zjistit počet milisekund uplynulých od \"spuštění programu\". TIM2 a TIM3 TIM2 a TIM3 je trochu složitější, ale zde ukážeme jen jeho základní použití. ( PWM necháme na samostatný post: Použití časovače jako generátoru PWM ) TIM2 /3 je 16 bitový – může tedy čítat do 65535 a předdělička umožňuje dělit /1, /2, /4, /8, /16, /32, /64, /128, /256, /512, /1024, /2048, /4096, /8192, /16384 a /32768. Takže například pokud vytváříme cokoli, co pracuje s časem a potřebujeme spustit určitý kód vždy přesně v intervalu \\(1\\,\\mathrm{s}\\) , může inicializace časovače vypadat například takto: /*---- TIM2 setup ---------*/ TIM2_TimeBaseInit ( TIM2_PRESCALER_512 , 31250 - 1 ); // 16MHz/512/31250 == 1Hz TIM2_Cmd ( ENABLE ); // povolí TIM2 TIM2_ITConfig ( TIM2_IT_UPDATE , ENABLE ); // povolí přerušení od TIM2 enableInterrupts (); // globálně povolí přerušení nastavení TIM3 je analogické: /*---- TIM3 setup ---------*/ TIM3_TimeBaseInit ( TIM3_PRESCALER_16 , 12345 - 1 ); // ~81Hz TIM3_ITConfig ( TIM3_IT_UPDATE , ENABLE ); TIM3_Cmd ( ENABLE ); No a ještě rutiny přerušení… Opět platí, že rutiny přerušení buď necháme v souboru stm8_it.c a proměnné označíme pomocí direktivy extern nebo si rutiny přesuneme do modulu/souboru ve kterém je proměnná definována . INTERRUPT_HANDLER ( TIM2_UPD_OVF_BRK_IRQHandler , 13 ) { TIM2_ClearFlag ( TIM2_FLAG_UPDATE ); // vymažu vlaku signalizující udelam_neco_zajimaveho (); sec ++ ; a_jeste_neco_jineho (); } INTERRUPT_HANDLER ( TIM3_UPD_OVF_BRK_IRQHandler , 15 ) { TIM3_ClearFlag ( TIM3_FLAG_UPDATE ); LED_REVERSE ( G ); } Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: https://github.com/spseol/ STM8 - TIM23 -zaklad","tags":"MITka","url":"zakladni-pouziti-casovace.html","loc":"zakladni-pouziti-casovace.html"},{"title":"Oddělená kompilace a vlastní knihovny","text":"ahoj aaa aaa bbb dfjdk konec","tags":"MITka","url":"oddelena-kompilace-a-vlastni-knihovny.html","loc":"oddelena-kompilace-a-vlastni-knihovny.html"}]};