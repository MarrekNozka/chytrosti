var tipuesearch = {"pages":[{"title":"O mně","text":"Nacházíte se na webových stránkách jednoho šíleného učitele z VOŠ a SPŠE Olomouc . Tyto stránky jsou určeny pro podporu mojí výuky. Každé téma, které aktuálně vyučuji, tady má svou stránku. Některé stránky podávají souhrnné informace, některé jsou jen sbírkou odkazů na jiná místa na internetu. Pokud vám tu něco chybí, napište mi. Pokud najdete chybu, napište mi. Motto Nikdo nevěděl, odkud přišli, ale najednou byli v Lese: Klokanice a Klokánek. Když se Pú zeptal Kryštůfka Robina: „Jak se sem dostali?\", Kryštůfek Robin řekl: „Obvyklým způsobem, jestli víš, jak to myslím, Pú,\" a Pú, který to nevěděl, řekl: „Aha!\" Pak dvakrát kývl hlavou a řekl: „Obvyklým způsobem. Ach tak!\" Marek Nožka","tags":"pages","url":"https://chytrosti.marrek.cz/pages/o-mne.html","loc":"https://chytrosti.marrek.cz/pages/o-mne.html"},{"title":"PRG","text":"Tahák Vytvořil jsem tahák, kde je z Pythonu více-méně vše, co byste měli mít v pohotovostní výbavě. Tyto texty lze číst buď na Githubu nebo nbvieweru . Instalace návod zde . Editor Základní instalace Pythonu už sama v sobě obsahuje jednoduché vývojové prostředí a jednoduchou interaktivní konzolu IDLE . Toto prostředí je poměrně jednoduché, ale rozhodně se nedá říct, že by se v něm nedalo pracovat. Existuje ale celá řada hezčích a propracovanějších vývojových prostředí . Já doporučuji VSCode/Codium. Visual Studio Code je brilantní open-source editor z dílny firmy Microsoft. Pokud do něj doinstalujete doplněk ms-python.python získáte vývojové prostředí, ve kterém vám s největší pravděpodobností nebude nic chybět. Jen ještě doplním, že pokud by vám (stejně jako mně) vadilo, že Microsoft do balíčku s VSCode zabalí i telemetrii (dřív se tomu říkalo špehování), tak existuje projekt Codium , který tímto neduhem netrpí. Codium má marketplace nasměrovaný trošku jinam . Git Git najdete na https://git-scm.com/ . Ovládá se z příkazové řádky. Pokud toužíte po nějakém grafickém ovládání stačí si vybrat z dlouhého seznamu ten, co se vám bude zdát nejhezčí. GitHub má svou vlastní grafickou aplikaci . Vynikajícím začátkem s Gitem je volně šiřitelná kniha Pro Git , ve které najdete vše potřebné v češtině. Lze číst i na webu: první vydání – celé v češtině druhé vydání – není přeloženo celé; můžete se tedy zapojit do překladu . Pro efektivní používaní tohoto skvělého nástroje vám stačí přečíst si první tři kapitoly . Nenechte se tedy odradit, stojí to jistě za to. Zde je ještě malý rychlokurs (pokud někdo není spokojen s knihou): Git Instalace gitu Větvení v Gitu Ignorování souborů Spolupráce a Open source Spolupráce a Git Ještě jedna drobnost: pokud se vám nechce pořád dokola zadávat při nahrávání své práce na GitHub uživatelské jméno a heslo použijte ssh klíče . K tomu se dobře hodí například putty . Pokusy a hračičky https://learngitbranching.js.org/ Oh my Git: https://ohmygit.org/","tags":"Programování","url":"https://chytrosti.marrek.cz/prg.html","loc":"https://chytrosti.marrek.cz/prg.html"},{"title":"MIT","text":"Pro výuku mikroprocesorové techniky používáme vývojovou desku Nucleo- 8S208RB s mikroprocesorem STM8S208RB . Dokumentace Celá řada STM8S používá stejnou sadu periferií. Jejich popis najdete v reference manuálu zde . Různé čipy pak obsahují různou sadu těchto periferií. Co přesně se nachází na kterém čipu (plus další specifické věci) lze najít v datasheetu: STM8S208 zde STM8S103 zde STM8S105 zde Elektromyš Michal Dudka píše skvělý web o programování mikrokontrokérů: http://elektromys.eu . V sekci STM8 najdete spoustu pro nás zajímavých věcí: Vstupy a výstupy 1 – základy Vstupy a výstupy 2 – tlačítko Vstupy a výstupy 3 – logické úrovně Vstupy a výstupy 4 – PullUp rezistory Vstupy a výstupy 5 – Open-Drain Ovládání displeje s MAX7219 Clock Alfanumerické LCD Knihovna milis – \"Multitasking\" Stavový automat Další velice cenné informace nejdete v sekcích: Elektro Různé krátké poznámky Ze stejné dílny pochází tyto pro nás zajímavé články: IR senzor I2C – Relativně jednoduše Periferie Generování zvuku – základy Základní použití časovače Použití časovače jako generátoru PWM Ultrazvukový měřič vzdálenosti pomocí timeru TIM2 Součástky Seznam součástek, které se můžou hodit pro naše projekty: https://www.tme.eu/cz/parking/b76826f5b8a05c725adc67a6c5509e9dcd24e9ff.html Na váš návrh rád seznam doplním. Šablona pro založení projektu moje šablona pro vývoj SDCC a GNU Make https://github.com/spseol/start-stm8 vzorový projekt Michala Dudky http://www.elektromys.eu/stm8s208_vzor.rar (případně zip) http://www.elektromys.eu/stm8s105_vzor.rar (případně zip) OpenSource nástroje nejen pro Linux Kompilátor SDCC Jako vývojové prostředí doporučuji VSCodium Starší anglický návod s několika mouchama: https://github.com/hbendalibraham/stm8_started Kompletní a novější český návod: připravuje se :) … a moje STM8S šablona https://github.com/spseol/start-stm8 Nástroje pro Widle Vše velmi hezky zpracoval Michal Dudka na Elektromyši . Jako vývojové prostředí používáme STVD s komipilátorem Cosmic . Oba nástroje je možné bezplatně používat, když se zaregistrujete. Bohužel nejsou ani jeden OpenSource . Pár odkazů souvisejících s jazykem C http://www.fit.vutbr.cz/~martinek/clang/ http://jaknaprojekty.davidm.cz/ https://www.tutorialspoint.com/cprogramming/ Wikibook Programuje v jazyce C .","tags":"MITka","url":"https://chytrosti.marrek.cz/mit.html","loc":"https://chytrosti.marrek.cz/mit.html"},{"title":"Ultrazvukový měřič vzdálenosti pomocí timeru TIM2","text":"zde se časem objeví zajímavý text :) Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: základní princip – větev princip main.c řešení typu Stavový automat – větev stav_automat main.c","tags":"MITka","url":"https://chytrosti.marrek.cz/ultrazvukovy-meric-vzdalenosti-pomoci-timeru-tim2.html","loc":"https://chytrosti.marrek.cz/ultrazvukovy-meric-vzdalenosti-pomoci-timeru-tim2.html"},{"title":"Použití časovače jako generátoru PWM","text":"TIM2 a TIM3 zde se časem objeví zajímavý text :) Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: RGB LED – RGB_LED main.c","tags":"MITka","url":"https://chytrosti.marrek.cz/pouziti-casovace-jako-generatoru-pwm.html","loc":"https://chytrosti.marrek.cz/pouziti-casovace-jako-generatoru-pwm.html"},{"title":"Generování zvuku — základy","text":"Zvuk je jak známo mechanické vlnění. Pro jeho vyloudění tedy potřebujeme nějaký \"vlnič\" – tedy elektro-akustický měnič. Nejjednodušší je asi použít piezo měnič. Ten má ovšem poněkud omezený frekvenční rozsah. Jeho frekvenční charakteristika může vypadat například takto: (Mimochodem prý existuje nějaký výzkum, podle kterého optimální frekvence pro budík je 100 Hz; nebo to bylo 300 Hz? Prostě poměrně nízký kmitočet. Ale levné bezporuchové piezo-měniče takto nízko prostě nejdou. Tak na nás ty budíky pískají a pípají a my vstáváme potom naštvaní.) Další možností je použít reproduktorek. V tomto případě je třeba posílit výstup tranzistorem. Zapojení tedy může vypadat například takto: Tranzistor je ve spínacím režimu a membrána reproduktoru má pouze dvě polohy. Tedy klidovou polohu (bez proudu) nebo výchylku odpovídající kladnému proudu. Do výchylky odpovídající zápornému proudu se membrána nedostane, protože proud protéká vždy jedním směrem. Dioda D1 vybíjí cívku reproduktoru, při sestupné hraně. Program, který nám vyloudí frekvenci \\(500\\,\\mathrm{Hz}\\) může vypadat například takto. Perioda je \\(2\\,\\mathrm{ms}\\) . Půl periody tedy \\(1\\,\\mathrm{ms}\\) . 1 2 3 4 5 6 7 8 9 10 11 void main ( void ) { init (); while ( 1 ) { PZ_UP ; delay_ms ( 1 ); PZ_DOWN ; delay_ms ( 1 ); } } Pokud chci jen pípnout a poté nechat chvilku ticho jednoduše nebudu cvičit s membránou do nekonečna, ale pouze několikrát ( \\(20 \\cdot 2\\,\\mathrm{ms}\\) ) a pak nechám chvilku ticho. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void main () { init (); uint16_t i ; while ( 1 ) { for ( i = 0 ; i < 20 ; ++ i ) { PZ_UP ; delay_ms ( 1 ); PZ_DOWN ; delay_ms ( 1 ); } delay_ms ( 60 ); } } Tento způsob práce je ale blokující, protože se pořád jen čeká. Mikroprocesor vlastně pořádně nemůže dělat nic jiného. Proto použijeme multitasking 1 a stavový automat . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 void main ( void ) { uint32_t timeL = 0 ; uint32_t lastTime = 0 ; uint16_t count = 0 ; enum state_of { STATE_PAUSE , STATE_UP , STATE_DOWN } state = STATE_UP ; uint32_t time = 0 ; init (); while ( 1 ) { switch ( state ) { case STATE_PAUSE : PZ_DOWN ; // v pauze dám repráček do klodového stavu if ( milis () - lastTime > 4321 ) { lastTime = milis (); state = STATE_UP ; } break ; case STATE_UP : PZ_UP ; if ( milis () - lastTime >= 4 ) { lastTime = milis (); state = STATE_DOWN ; } break ; case STATE_DOWN : PZ_DOWN ; if ( count >= 10 ) { count = 0 ; lastTime = milis (); state = STATE_PAUSE ; break ; } if ( milis () - lastTime >= 4 ) { lastTime = milis (); count ++ ; state = STATE_UP ; } break ; default : state = STATE_PAUSE ; } if ( milis () - timeL > 500 ) { timeL = milis (); LED_REVERSE ; } } } Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: https://github.com/spseol/ STM8 -zvuk-zaklad knihovna milis ↩","tags":"MITka","url":"https://chytrosti.marrek.cz/generovani-zvuku-zaklady.html","loc":"https://chytrosti.marrek.cz/generovani-zvuku-zaklady.html"},{"title":"Základní použití časovače","text":"Náš STM8S208RB má na těle celkem čtyři časovače: TIM1 , TIM2 , TIM3 a TIM4 . TIM4 TIM4 je nejjednodušší. Čítač je 8-bitový a předdělička umožňuje dělit kmitočet /1, /2, /4, /8, /16, /32, /64 a /128. Auto-reload register říká kam až se bude čítat – tedy nastavuje strop časovače. Nastavení se děje pomocí funkce TIM4_TimeBaseInit(PRESCALER, PERIOD) , kde PRESCALER je makro, pro nastavení děličky a PERIOD je 8-bitové číslo. 1 TIM4_TimeBaseInit ( TIM4_PRESCALER_128 , 125 - 1 ); Takže pokud máme nastaven kmitočet na 16MHz znamená to že čítač čítá do hodnoty 125 (respektive 124 protože čítáme od nuly) s frekvencí 16MHz/128 == 125 kHz . Znamená to tedy, že každou milisekundu dojde k auto-reloadu a je vyvoláno přerušení od časovače TIM4 . Aby vše fungovalo musíme: povolit TIM4 povolit přerušení od TIM4 globálně povolit přerušení napsat tělo obslužné rutiny přerušení. 1 2 3 4 5 6 void setup ( void ) { TIM4_Cmd ( ENABLE ); // povolí TIM4 TIM4_ITConfig ( TIM4_IT_UPDATE , ENABLE ); // povolí přerušení od TIM4 enableInterrupts (); // globálně povolí přerušení ...... } Rutina přerušení se standardně nachází v souboru stm8_it.c . Stačí ji najít přepsat. Pokud potřebujete v rutině přerušení pracovat s proměnnou definovanou v main.c (což je myslím téměř vždy) je třeba tuto proměnnou označit direktivou extern nebo rutinu přesunout přímo do souboru main.c . Více o tom se dočtete v postu Kompilace a knihovny . 1 2 3 4 5 6 /*--- rutina obsluhy přerušení ---*/ INTERRUPT_HANDLER ( TIM4_UPD_OVF_IRQHandler , 23 ) { TIM4_ClearFlag ( TIM4_FLAG_UPDATE ); // vymažu vlajku signalizující přerušení miliseconds ++ ; // udělám co je třeba.... } Všimněte si prosím, že první, co se v rutině přerušení dělá, je, že se vymaže vlajka , která označuje, že k přerušení došlo. Tento kód je například použito v knihovně milis , která umožňuje zjistit počet milisekund uplynulých od \"spuštění programu\". TIM2 a TIM3 TIM2 a TIM3 je trochu složitější, ale zde ukážeme jen jeho základní použití. ( PWM necháme na samostatný post: Použití časovače jako generátoru PWM ) TIM2 /3 je 16 bitový – může tedy čítat do 65535 a předdělička umožňuje dělit /1, /2, /4, /8, /16, /32, /64, /128, /256, /512, /1024, /2048, /4096, /8192, /16384 a /32768. Takže například pokud vytváříme cokoli, co pracuje s časem a potřebujeme spustit určitý kód vždy přesně v intervalu \\(1\\,\\mathrm{s}\\) , může inicializace časovače vypadat například takto: 1 2 3 4 5 /*---- TIM2 setup ---------*/ TIM2_TimeBaseInit ( TIM2_PRESCALER_512 , 31250 - 1 ); // 16MHz/512/31250 == 1Hz TIM2_Cmd ( ENABLE ); // povolí TIM2 TIM2_ITConfig ( TIM2_IT_UPDATE , ENABLE ); // povolí přerušení od TIM2 enableInterrupts (); // globálně povolí přerušení nastavení TIM3 je analogické: 1 2 3 4 /*---- TIM3 setup ---------*/ TIM3_TimeBaseInit ( TIM3_PRESCALER_16 , 12345 - 1 ); // ~81Hz TIM3_ITConfig ( TIM3_IT_UPDATE , ENABLE ); TIM3_Cmd ( ENABLE ); No a ještě rutiny přerušení… Opět platí, že rutiny přerušení buď necháme v souboru stm8_it.c a proměnné označíme pomocí direktivy extern nebo si rutiny přesuneme do modulu/souboru ve kterém je proměnná definována . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 INTERRUPT_HANDLER ( TIM2_UPD_OVF_BRK_IRQHandler , 13 ) { TIM2_ClearFlag ( TIM2_FLAG_UPDATE ); // vymažu vlaku signalizující udelam_neco_zajimaveho (); sec ++ ; a_jeste_neco_jineho (); } INTERRUPT_HANDLER ( TIM3_UPD_OVF_BRK_IRQHandler , 15 ) { TIM3_ClearFlag ( TIM3_FLAG_UPDATE ); LED_REVERSE ( G ); } Zdrojové kódy Kompletní zdrojové kódy naleznete v repositáři na GitHubu: https://github.com/spseol/ STM8 - TIM23 -zaklad","tags":"MITka","url":"https://chytrosti.marrek.cz/zakladni-pouziti-casovace.html","loc":"https://chytrosti.marrek.cz/zakladni-pouziti-casovace.html"},{"title":"Oddělená kompilace a vlastní knihovny","text":"ahoj aaa aaa bbb dfjdk konec","tags":"MITka","url":"https://chytrosti.marrek.cz/oddelena-kompilace-a-vlastni-knihovny.html","loc":"https://chytrosti.marrek.cz/oddelena-kompilace-a-vlastni-knihovny.html"},{"title":"Vývoj STM8 s OpenSource nástroji","text":"https://github.com/hbendalibraham/stm8_started Flashing Kompilace Debug","tags":"MITka","url":"https://chytrosti.marrek.cz/vyvoj-stm8-s-opensource-nastroji.html","loc":"https://chytrosti.marrek.cz/vyvoj-stm8-s-opensource-nastroji.html"},{"title":"SIT","text":"Totot tuje","tags":"SÍTě","url":"https://chytrosti.marrek.cz/sit.html","loc":"https://chytrosti.marrek.cz/sit.html"},{"title":"PSK","text":"kokodák lalal","tags":"PSKáčko","url":"https://chytrosti.marrek.cz/psk.html","loc":"https://chytrosti.marrek.cz/psk.html"}]};